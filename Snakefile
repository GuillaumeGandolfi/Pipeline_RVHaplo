## Snakemake - Pipeline RVHaplo

import os

## Configuration files parameters
filter_reads = config["FILTER_READS"]["minimum_length"]
sequencing_summary = config["SEQUENCING_SUMMARY"]["presence"]

## Extensions of files generated by bwa_index
BWA_INDEX = ['amb','ann','bwt','pac','sa']

## Path of folders (config file)
work_directory = config["DIRECTORIES"]["working_directory"]
res_directory = config["DIRECTORIES"]["rvhaplo_results"]

## Path of files (config file)
reference_file = config["FILES"]["reference_file"]
all_refs = config["FILES"]["all_refs_file"]
CP_refs = config["FILES"]["all_refs_CP"]

## Path of fastq files
path_fastq = config["DIRECTORIES"]["fastq_files"]
fastq_files = []
for file in os.listdir(path_fastq):
    if (file.endswith('.fastq')) or (file.endswith('.fasta')):
        fastq_files.append(os.path.splitext(os.path.basename(file))[0])

## Path of sequencing_summary files
path_summary = config["DIRECTORIES"]["sequencing_summary"]
if sequencing_summary == True:
    summary_files = []
    for file in os.listdir(path_summary):
        if file.endswith('.txt'):
            summary_files.append(os.path.splitext(os.path.basename(file))[0])

## Name of the reference without path and extension
ref_without_ext = os.path.splitext(os.path.basename(reference_file))[0]

## Name of the reference without path
basename_ref = os.path.basename(reference_file)

## Path of the reference file
path_ref = os.path.dirname(reference_file)

## Number of threads
threads_RVHaplo = config["PARAMS"]["RVHaplo"]["threads"]
threads_bwamem = config["PARAMS"]["bwa_mem"]["threads"]


if sequencing_summary == True:
    rule all:
        input:
            expand(f"{path_summary}/{{summary}}.html",summary=summary_files),
            tree=expand(f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/NJ_tree.nwk", fastq=fastq_files) if filter_reads != 0
            else expand(f"{res_directory}/{{fastq}}/{{fastq}}_allreads/NJ_tree.nwk", fastq=fastq_files),
            aln_CP= expand(f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/alignment_CP.fasta",fastq=fastq_files) if filter_reads != 0
            else expand(f"{res_directory}/{{fastq}}/{{fastq}}_allreads/alignment_CP.fasta", fastq=fastq_files)
else:
    rule all:
        input:
            tree=expand(f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/NJ_tree.nwk",fastq=fastq_files) if filter_reads != 0
            else expand(f"{res_directory}/{{fastq}}/{{fastq}}_allreads/NJ_tree.nwk",fastq=fastq_files),
            aln_CP= expand(f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/alignment_CP.fasta",fastq=fastq_files) if filter_reads != 0
            else expand(f"{res_directory}/{{fastq}}/{{fastq}}_allreads/alignment_CP.fasta", fastq=fastq_files)


## PycoQC rule (generate interactive plots for ONT sequencing data)
rule pycoQC:
    input:
        summary = f"{path_summary}/{{summary}}.txt"
    output:
        html = f"{path_summary}/{{summary}}.html"
    conda:
        "envs/pycoQC.yml"
    shell:
        "pycoQC --summary_file {input} --html_outfile {output}"

## Convert '.fastq' files to 'fasta' files
rule convert_fasta:
    input:
        fastq = f"{path_fastq}/{{fastq}}.fastq"
    output:
        conv_fasta = f"{path_fastq}/{{fastq}}.fasta"
    envmodules:
        "bioinfo/seqtk/1.3-r106"
    shell:
        "seqtk seq -a {input.fastq} > {output.conv_fasta}"

## Apply a length filter on the reads
rule cut_fasta:
    input:
        fasta = rules.convert_fasta.output.conv_fasta or f"{path_fastq}/{{fastq}}.fasta"
    output:
        fasta_cut = expand(f"{path_fastq}/{{fastq}}_sup{filter_reads}.fasta", fastq=fastq_files)
    envmodules:
        "bioinfo/seqkit/2.1.0"
    params:
        filter = filter_reads
    shell:
        "seqkit seq -g -m {params.filter} {input} > {output}"

## Index the reference sequence
rule bwa_index:
    input:
        reference = reference_file
    output:
        index_file = expand(f"{path_ref}/{basename_ref}.{{suffix}}", suffix=BWA_INDEX)
    envmodules:
        "bioinfo/bwa/0.7.17"
    shell:
        "bwa index {input}"

## Mapping of the reads on the reference
rule bwa_mem:
    threads: threads_bwamem
    input:
        reference = reference_file,
        index_file = rules.bwa_index.output.index_file,
        fasta = rules.cut_fasta.output.fasta_cut if filter_reads != 0 else f"{path_fastq}/{{fastq}}.fasta"
    output:
        sam_file = f"{work_directory}/mapped/{{fastq}}_sup{filter_reads}_map{ref_without_ext}.sam"
        if filter_reads != 0 else f"{work_directory}/mapped/{{fastq}}_map{ref_without_ext}.sam"
    envmodules:
        "bioinfo/bwa/0.7.17"
    shell:
        "bwa mem -t {threads} {input.reference} {input.fasta} > {output}"

## RVHaplo tool (reconstruction of viral haplotypes)
rule RVHaplo:
    threads: threads_RVHaplo
    params:
        outdir = f"{res_directory}/{{fastq}}/{{fastq}}"
    input:
        sam = rules.bwa_mem.output.sam_file,
        reference = reference_file
    output:
        haplo = f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/rvhaplo_haplotypes.fasta" if filter_reads != 0
        else f"{res_directory}/{{fastq}}/{{fastq}}_allreads/rvhaplo_haplotypes.fasta"
    conda:
        "envs/rvhaplo.yml"
    shell:
        "./rvhaplo.sh -i {input.sam} -r {input.reference} -o {params.outdir}_sup{filter_reads} -t {threads} || true" if filter_reads != 0
        else "./rvhaplo.sh -i {input.sam} -r {input.reference} -o {params.outdir}_allreads -t {threads} || true"

## Merge haplotype files with the refs files
rule merge:
    input:
        haplotypes = rules.RVHaplo.output.haplo,
        all_refs_file = all_refs,
        all_CP_refs = CP_refs
    output:
        haplo_refs = f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/haplo_refs.fasta" if filter_reads != 0
        else f"{res_directory}/{{fastq}}/{{fastq}}_allreads/haplo_refs.fasta",
        haplo_refs_CP = f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/haplo_refs_CP.fasta" if filter_reads != 0
        else f"{res_directory}/{{fastq}}/{{fastq}}_allreads/haplo_refs_CP.fasta"
    run:
        with open(input.all_refs_file) as file:
            refs = file.read()
        with open(input.all_CP_refs) as file:
            refs_CP = file.read()

        haplo_files = input.haplotypes
        with open(haplo_files) as file:
            haplo1 = file.read()
            haplo2 = file.read()
        haplo1 += refs
        haplo2 += refs_CP

        merge_file_1 = output.haplo_refs
        with open(merge_file_1, "w") as file:
            file.write(haplo1)

        merge_file_2 = output.haplo_refs_CP
        with open(merge_file_2, "w") as file:
            file.write(haplo2)

## Multiple alignment (muscle) of haplotypes with sequences of RYMV isolates + reference sequences
rule alignment_ref:
    input:
        haplo_refs = rules.merge.output.haplo_refs,
        haplo_refs_CP = rules.merge.output.haplo_refs_CP
    output:
        aln=f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/alignment.fasta" if filter_reads != 0
        else f"{res_directory}/{{fastq}}/{{fastq}}_allreads/alignment.fasta",
        aln_CP = f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/alignment_CP.fasta" if filter_reads != 0
        else f"{res_directory}/{{fastq}}/{{fastq}}_allreads/alignment_CP.fasta"
    envmodules:
        "bioinfo/muscle/3.8.31"
    shell:
        """
        muscle3.8.31_i86linux64 -in {input.haplo_refs} -out {output.aln}
        muscle3.8.31_i86linux64 -in {input.haplo_refs_CP} -out {output.aln_CP}
        """


rule phylogenetic_tree:
    input:
        alignment = rules.alignment_ref.output.aln
    output:
        tree = f"{res_directory}/{{fastq}}/{{fastq}}_sup{filter_reads}/NJ_tree.nwk" if filter_reads != 0
        else f"{res_directory}/{{fastq}}/{{fastq}}_allreads/NJ_tree.nwk"
    script:
        "python_script/tree.py"
